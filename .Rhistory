plot_volcano_pval(Fold_Change = stat_phos_fc[,i],P_Value = stat_phos_pval[,i],show_lines = F,left = 0,right = 0,col_cutoff = 0,xlim = max(abs(log2(stat_phos_fc[,i]+1)))*1.1,ylim = 3.5)
dev.off()
}
stat_all_pval <- stats_mat_all[,grep('pval',colnames(stats_mat_all))]
stat_all_fc <- stats_mat_all[,grep('FC',colnames(stats_mat_all))]
colnames(stat_all_pval) <- gsub('_pval','',colnames(stat_all_pval))
for(i in 1:ncol(stat_all_pval)){
tiff(paste(outpath,'volcano/',colnames(stat_all_pval)[i],'_total.tiff',sep = ''),width = 800,height = 800)
plot_volcano_pval(Fold_Change = stat_all_fc[,i],P_Value = stat_all_pval[,i],show_lines = F,left = 0,right = 0,col_cutoff = 0,xlim = 1.1,ylim = 3.5)
dev.off()
}
stat_phos_pval <- stats_mat_phos[,grep('pval',colnames(stats_mat_phos))]
stat_phos_fc <- stats_mat_phos[,grep('FC',colnames(stats_mat_phos))]
colnames(stat_phos_pval) <- gsub('_pval','',colnames(stat_phos_pval))
for(i in 1:ncol(stat_phos_pval)){
tiff(paste(outpath,'volcano/',colnames(stat_phos_pval)[i],'_phos.tiff',sep = ''),width = 800,height = 800)
plot_volcano_pval(Fold_Change = stat_phos_fc[,i],P_Value = stat_phos_pval[,i],show_lines = F,left = 0,right = 0,col_cutoff = 0,xlim = max(abs(log2(stat_phos_fc[,i]+1)))*1.1,ylim = 3.5)
dev.off()
}
library(VennDiagram)
venn_list_total <- list()
for(i in colnames(stat_all_pval)[1:4]){
venn_list_total[[i]] <- rownames(stat_all_pval)[stat_all_pval[,i]<0.05]
}
venn.plot <- venn.diagram(venn_list_total,paste(outpath,"Venn_total.tiff",sep = ''),width = 4560)
venn_list_phos <- list()
for(i in colnames(stat_phos_pval)[1:4]){
venn_list_phos[[i]] <- rownames(stat_phos_pval)[stat_phos_pval[,i]<0.05]
}
venn.plot <- venn.diagram(venn_list_phos,paste(outpath,"Venn_phos.tiff",sep = ''),width = 4560)
#heatmap with sig genes only
sig_genes_total <- rownames(stats_mat_all)[apply(stats_mat_all[,grep('pval')], 1, function(x)sum(x<0.05))>0]
#heatmap with sig genes only
sig_genes_total <- rownames(stats_mat_all)[apply(stats_mat_all[,grep('pval',colnames(stats_mat_all))], 1, function(x)sum(x<0.05))>0]
sig_genes_total
sig_genes_phos <- rownames(stats_mat_phos)[apply(stats_mat_phos[,grep('pval',colnames(stats_mat_phos))], 1, function(x)sum(x<0.05))>0]
sig_genes_phos
head(phosphoSet_plot_data)
tiff(paste(outpath,'heatmap_total_sig_only.tiff',sep = ''))
pheatmap(proteomset_plot_data[sig_genes_total,-(total_drop)],annotation_col = meta_df,cluster_cols = F,show_rownames = F,scale = 'none')
dev.off()
tiff(paste(outpath,'heatmap_phos_sig_only.tiff',sep = ''))
pheatmap(phosphoSet_plot_data[sig_genes_phos,-(phos_drop)],annotation_col = meta_df,cluster_cols = F,show_rownames = F,scale = 'none')
dev.off()
proteomset_comb_norm3 <- proteomset_comb_norm2[,-(total_drop)]
col_table <- rep(1:5,each=4)[-(total_drop)]
df_pca_total  <- prcomp(t(proteomset_comb_norm3))
plot3d(df_pca_total$x[,1:3], col=col_table,type = 'p',size=11)
legend3d("topright", legend =rownames(meta),col=1:5,pch=16,cex=1)
snapshot3d(paste(outpath,'total_pca3d_pc1_pc3.tiff',sep = ''))
plot3d(df_pca_total$x[,c(1,3,2)], col=col_table,type = 'p',size=11)
legend3d("topright", legend =rownames(meta),col=1:5,pch=16,cex=1)
snapshot3d(paste(outpath,'total_pca3d_pc1_pc2.tiff',sep = ''))
plot3d(df_pca_total$x[,c(2,1,3)], col=col_table,type = 'p',size=11)
legend3d("topright", legend =rownames(meta),col=1:5,pch=16,cex=1)
snapshot3d(paste(outpath,'total_pca3d_pc2_pc3.tiff',sep = ''))
#phos
phosphoSet_comb_norm3 <- phosphoSet_comb_norm2[,-(phos_drop)]
col_table <- rep(2:6,each=4)[-(phos_drop)]
df_pca_phos  <- prcomp(t(phosphoSet_comb_norm3))
plot3d(df_pca_phos$x[,1:3], col=col_table,type = 'p',size=11)
legend3d("topright", legend =rownames(meta),col=1:5,pch=16,cex=1)
snapshot3d(paste(outpath,'phos_pca3d_pc1_pc3.tiff',sep = ''))
plot3d(df_pca_phos$x[,c(1,3,2)], col=col_table,type = 'p',size=11)
legend3d("topright", legend =rownames(meta),col=1:5,pch=16,cex=1)
snapshot3d(paste(outpath,'phos_pca3d_pc1_pc2.tiff',sep = ''))
plot3d(df_pca_phos$x[,c(2,1,3)], col=col_table,type = 'p',size=11)
legend3d("topright", legend =rownames(meta),col=1:5,pch=16,cex=1)
snapshot3d(paste(outpath,'phos_pca3d_pc2_pc3.tiff',sep = ''))
args='/test/'
args='/test/'
download_script = '/storage/htc/bdm/Collaboration/liu_rnaseq/src/download_fastq.sh'
ref_genome = '/storage/htc/bdm/ref_genomes/mouse/star_ref'
project_dir = '/storage/htc/bdm/Collaboration/liu_rnaseq_test/'
meta_file = '/storage/htc/bdm/Collaboration/liu_rnaseq/src/meta_info.csv'
rawdata_path <- paste(project_dir,'rawdata/',sep = '')
trim_data_path <- paste(project_dir,'trimdata/',sep = '')
alignment_result <- paste(project_dir,'alignment_result/',sep = '')
output_result <- paste(project_dir,'final_result/',sep = '')
job_name <- substr(gsub('.+/(.+)/','\\1',project_dir),1,8)
source('https://raw.githubusercontent.com/chrischen1/rnaseq/master/de_rnaseq.R')
job_name
library(org.Mm.eg.db)
library(clusterProfiler)
library(ReactomePA)
library(pheatmap)
output_path = '~/Dropbox/MU/workspace/liu_rnaseq/plots/'
cnt_result <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/counts.csv',as.is = T,row.names = 1)
de_result <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/de_results.csv',as.is = T,row.names = 1)
meta <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/meta_info.csv',as.is = T,row.names = 1)
rownames(meta) <- gsub('^D','',rownames(meta))
#heatmap
genes_ens <- de_result[de_result$fdr<0.05,]
cnt_result <- cnt_result[rownames(genes_ens),]
png(paste(output_path,'heatmap.png',sep = ''))
pheatmap(log2(cnt_result+1),show_rownames = F,cluster_cols = F,annotation_col = meta[,2,drop=F],scale = 'column')
dev.off()
eg = bitr(rownames(genes_ens), fromType="ENSEMBL", toType="ENTREZID", OrgDb="org.Mm.eg.db")
genes_ens1 <- genes_ens[eg$ENSEMBL,]
genes_ens1 <- cbind(genes_ens1,'ENTREZID'=eg$ENTREZID)
# Pathway Enrichment Analysis
x <- enrichPathway(gene=genes_ens1$ENTREZID,organism = 'mouse',pvalueCutoff=0.05, readable=T)
x
aaa=x@result
View(aaa)
aaa$geneID[1]
library(org.Mm.eg.db)
library(clusterProfiler)
library(ReactomePA)
library(pheatmap)
output_path = '~/Dropbox/MU/workspace/liu_rnaseq/plots/'
cnt_result <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/counts.csv',as.is = T,row.names = 1)
de_result <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/de_results.csv',as.is = T,row.names = 1)
meta <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/meta_info.csv',as.is = T,row.names = 1)
rownames(meta) <- gsub('^D','',rownames(meta))
#heatmap
genes_ens <- de_result[de_result$fdr<0.05,]
cnt_result <- cnt_result[rownames(genes_ens),]
png(paste(output_path,'heatmap.png',sep = ''))
pheatmap(log2(cnt_result+1),show_rownames = F,cluster_cols = F,annotation_col = meta[,2,drop=F],scale = 'column')
dev.off()
eg = bitr(rownames(genes_ens), fromType="ENSEMBL", toType="ENTREZID", OrgDb="org.Mm.eg.db")
genes_ens1 <- genes_ens[eg$ENSEMBL,]
genes_ens1 <- cbind(genes_ens1,'ENTREZID'=eg$ENTREZID)
View(cnt_result)
all_genes_ens <- rownames(cnt_result)
head(all_genes_ens)
all_genes_mapping <- bitr(all_genes_ens, fromType="ENSEMBL", toType="ENTREZID", OrgDb="org.Mm.eg.db")
head(all_genes_mapping)
#' conversion a gene by sample matrix from gene_id1 from gene_id2 by names in t[,1] to names in t[,2]
#'
#' @param m a gene by sample matrix
#' @param t conversion table
#' @return a gene by sample matrix with new gene_id
gene_matrix_conversion_by_table <- function(m,t){
library(reshape2)
library(dplyr)
genes <- t[,2]
names(genes) <- t[,1]
m <- cbind.data.frame(m,'name'=genes[rownames(m)],stringsAsFactors=F)
m <- m[!is.na(m$name),]
m2 <- m %>% group_by(name)%>% summarise_each(funs(sum))
m3 <- as.matrix(m2[,-1])
rownames(m3) <- m2$name
return(m3)
}
#' conversion a gene by sample matrix from gene_id1 from gene_id2
#'
#' @param m a gene by sample matrix
#' @param gene_id1 format of original gene id, must be valid filters name in Ensembl
#' @param gene_id2 format of destination gene id, must be valid attributes name in Ensembl
#' @return a gene by sample matrix with new gene_id
gene_matrix_conversion <- function(m,gene_id1='ensembl_gene_id',gene_id2='hgnc_symbol',dataset="hsapiens_gene_ensembl"){
target_genes <- gene_id_mapping(rownames(m),gene_id1,gene_id2,dataset)
target_genes <- target_genes[target_genes[,1]!=''&target_genes[,2]!='',]
gene_matrix_conversion_by_table(m,target_genes)
}
output_path = '~/Dropbox/MU/workspace/liu_rnaseq/plots/'
cnt_result <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/counts.csv',as.is = T,row.names = 1)
de_result <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/de_results.csv',as.is = T,row.names = 1)
meta <- read.csv('~/Dropbox/MU/workspace/liu_rnaseq/meta_info.csv',as.is = T,row.names = 1)
rownames(meta) <- gsub('^D','',rownames(meta))
#heatmap
genes_ens <- de_result[de_result$fdr<0.05,]
cnt_sig <- cnt_result[rownames(genes_ens),]
png(paste(output_path,'heatmap.png',sep = ''))
pheatmap(log2(cnt_sig+1),show_rownames = F,cluster_cols = F,annotation_col = meta[,2,drop=F],scale = 'column')
dev.off()
all_genes_ens <- rownames(cnt_result)
all_genes_mapping <- bitr(all_genes_ens, fromType="ENSEMBL", toType="ENTREZID", OrgDb="org.Mm.eg.db")
all_genes_mapping <- bitr(all_genes_ens, fromType="ENSEMBL", toType="NAME", OrgDb="org.Mm.eg.db")
all_genes_mapping <- bitr(all_genes_ens, fromType="ENSEMBL", toType="GENENAME", OrgDb="org.Mm.eg.db")
head(all_genes_mapping)
all_genes_mapping <- bitr(all_genes_ens, fromType="ENSEMBL", toType="SYMBOL", OrgDb="org.Mm.eg.db")
head(all_genes_mapping)
cnt_sbl<- gene_matrix_conversion_by_table(all_genes_ens,all_genes_mapping)
cnt_sbl<- gene_matrix_conversion_by_table(cnt_result,all_genes_mapping)
View(cnt_sbl)
de_res <- edgeR_wrapper(cnt_sbl,meta)
## de_rnaseq.R - functions for the differential expression analysis
##
## LSP RNAseq bcbio pipeline
## by Artem Sokolov, Chris Chen, et al.
## Retrieves count file and group information file from command line arguments,
## Returns a named list of values which is used by the main() function in run_de.R
get_args <- function(){
library(optparse)
## Define available options
option_list = list(
make_option(c("-c", "--count"), type="character", default=NULL,
help="Path to .count file from bcbio output, which is a ensumbl ID by sample ID matrix", metavar="character"),
make_option(c("-a", "--annotation"), type="character", default=NULL,
help="Path to group information file, which is a dataframe with 3 columns: group, condition and control
\n\tgroup: contains information which treatment samples will be compared against control cases in each group
\n\tcondition: indicates type of treatment, replicates have same condition
\n\tcontrol: TRUE for controls and FALSE for treatments
\n\torder of samples in annotation must be the same as samples in count table", metavar="character"),
make_option(c("-o", "--output"), type="character", default=NULL,
help="Path to save differential analysis results", metavar="character"),
make_option(c("-p", "--pairwise"), type="logical", default=TRUE,
help="If the P-values and FDR are given pairwise or as ANOVA-like test for any differences", metavar="TRUE/FALSE"),
make_option(c("-s", "--symbol"), type="logical", default=FALSE,
help="If gene symbols will be added to the output", metavar="TRUE/FALSE")
)
## Parse the arguments
opt_parser = OptionParser(option_list=option_list)
argv = parse_args(opt_parser)
## Basic verification
if (is.null(argv$count) || is.null(argv$annotation) || is.null(argv$output)){
print_help(opt_parser)
stop("Count table, annotation and output path must be provided.\n
usage: Rscript run_de.R -c path/to/rnaseq.count -a path/to/group_info.txt -o path/to/output", call.=FALSE)
}
return( argv )
}
#' transform TPM to RPKM
#'
#' @param combined output file end with .combined from bcbio.
#' @param tx2gene output file which maps ensumble ID to gene from bcbio.
#' @param spikes a vector of string defining the name of spikes.
#' @return p by n matrix for p genes across n samples
tpm2rpkm <- function(combined,tx2gene,spikes = NULL){
library(reshape2)
library(dplyr)
colnames(combined) <- tolower(colnames(combined))
gene_mapping <- cbind('transcript'= c(tx2gene$V1,spikes$GenBank),'gene' = c(tx2gene$V2,spikes$ERCC_ID))
genes <- gene_mapping[,2]
names(genes) <- gene_mapping[,1]
lib_size <- data.frame('numreads'=combined$numreads,'sample'=combined$sample)
x <- lib_size %>% group_by(sample) %>% summarise_each(funs(sum))
scale_factor <- x$numreads/1000000
names(scale_factor) <- x$sample
combined$RPM <- combined$numreads/scale_factor[combined$sample]
combined$RPKM <- combined$RPM/(combined$effectivelength/1000)
combined$gene <- genes[combined$name]
rpkm_combined <- data.frame('sample'=combined$sample,'gene'=combined$gene,'RPKM'=combined$RPKM)
rpkm_combined_gene <- rpkm_combined %>% group_by(sample,gene)%>% summarise_each(funs(sum))
rpkm_raw <- acast(rpkm_combined_gene,gene~sample)
return(rpkm_raw[-nrow(rpkm_raw),])
}
#' transform TPM to RPKM
#'
#' @param combined output file end with .combined from bcbio.
#' @param tx2gene output file which maps ensumble ID to gene from bcbio.
#' @param spikes a vector of string defining the name of spikes.
#' @return p by n matrix for p genes across n samples
sf2tpm <- function(combined,tx2gene,spikes = NULL){
library(reshape2)
library(dplyr)
colnames(combined) <- tolower(colnames(combined))
gene_mapping <- cbind('transcript'= c(tx2gene$V1,spikes$GenBank),'gene' = c(tx2gene$V2,spikes$ERCC_ID))
genes <- gene_mapping[,2]
names(genes) <- gene_mapping[,1]
combined$gene <- genes[combined$Name]
combined2 <- combined[!is.na(combined[,'gene']),]
tpm_combined <- data.frame('sample'=combined2$sample,'gene'=combined2$gene,'tpm_raw'=combined2$tpm)
tpm_combined_gene <- tpm_combined %>% group_by(sample,gene)%>% summarise_each(funs(sum))
tpm_raw <- acast(tpm_combined_gene,gene~sample)
return(tpm_raw)
}
#' get length of genes given a list of gene names
#'
#' @param gene_id_type types of gene ID, see ensembl bioMart package for possible types
#' @param dataset name of ensembl dataset
#' @return a named list of gene lengths, duplicate gene length records will be averaged
get_gene_length <- function(gene_names,gene_id_type='ensembl_gene_id',dataset="hsapiens_gene_ensembl"){
library(biomaRt)
library(reshape2)
library(dplyr)
ensembl <- useEnsembl(biomart="ensembl", dataset=dataset)
target_gene_raw <- getBM(attributes=c(gene_id_type,'transcript_length'),filters = gene_id_type, values = gene_names, mart = ensembl)
target_gene <- target_gene_raw %>% group_by(ensembl_gene_id)%>% summarise_all(funs(mean))
l <- target_gene$transcript_length
names(l) <- target_gene$ensembl_gene_id
return(l)
}
#' transform counts to TPM
#'
#' @param m p by n counts matrix for p genes across n samples
#' @param gene_length a named list of gene lengths
#' @return p by n TPM matrix for p genes across n samples
counts2tpm <- function(m,gene_length){
m <- m[names(gene_length),]
rpk <- m/gene_length
scaling <- colSums(rpk)/1000000
for(i in 1:ncol(rpk)){
rpk[,i] <- rpk[,i]/scaling[i]
}
rownames(rpk) <- names(gene_length)
return(rpk)
}
#' get hgnc_symbol from ensembl_gene_id
#'
#' @param ens vector of ensembl_gene_ids.
#' @return a dataframe with 2 columns: ensembl_gene_id and hgnc_symbol
ens2symbol <- function(ens){
library(biomaRt)
ensembl <- useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")
target_gene <- getBM(attributes=c('ensembl_gene_id','hgnc_symbol'),filters = 'ensembl_gene_id', values = ens, mart = ensembl)
return(target_gene)
}
#' get gene_id1 from gene_id2
#'
#' @param ids vector of gene_ids.
#' @param gene_id1 format of original gene id, must be valid filters name in Ensembl
#' @param gene_id2 format of destination gene id, must be valid attributes name in Ensembl
#' @return a dataframe with 2 columns: gene_id1 and gene_id2
gene_id_mapping <- function(ids,gene_id1='ensembl_gene_id',gene_id2='hgnc_symbol',dataset="hsapiens_gene_ensembl"){
library(biomaRt)
ensembl <- useEnsembl(biomart="ensembl", dataset=dataset)
target_gene <- getBM(attributes=c(gene_id1,gene_id2),filters = gene_id1, values = ids, mart = ensembl)
return(target_gene)
}
#' conversion a gene by sample matrix from gene_id1 from gene_id2 by names in t[,1] to names in t[,2]
#'
#' @param m a gene by sample matrix
#' @param t conversion table
#' @return a gene by sample matrix with new gene_id
gene_matrix_conversion_by_table <- function(m,t){
library(reshape2)
library(dplyr)
genes <- t[,2]
names(genes) <- t[,1]
m <- cbind.data.frame(m,'name'=genes[rownames(m)],stringsAsFactors=F)
m <- m[!is.na(m$name),]
m2 <- m %>% group_by(name)%>% summarise_each(funs(sum))
m3 <- as.matrix(m2[,-1])
rownames(m3) <- m2$name
return(m3)
}
#' conversion a gene by sample matrix from gene_id1 from gene_id2
#'
#' @param m a gene by sample matrix
#' @param gene_id1 format of original gene id, must be valid filters name in Ensembl
#' @param gene_id2 format of destination gene id, must be valid attributes name in Ensembl
#' @return a gene by sample matrix with new gene_id
gene_matrix_conversion <- function(m,gene_id1='ensembl_gene_id',gene_id2='hgnc_symbol',dataset="hsapiens_gene_ensembl"){
target_genes <- gene_id_mapping(rownames(m),gene_id1,gene_id2,dataset)
target_genes <- target_genes[target_genes[,1]!=''&target_genes[,2]!='',]
gene_matrix_conversion_by_table(m,target_genes)
}
## Resolves a filename by downloading the file if it's a synapse ID
## Returns a filename that can be directly used for loading by, e.g., read.delim
resolve.filename <- function( fn, syn.local   = "~/data/")
{
library(synapseClient)
if( substr( fn, 0, 3 ) == "syn" )
{
dir.create(syn.local,showWarnings = F)
s <- synGet( fn, downloadLocation = syn.local )
return( s@filePath )
}
return( fn )
}
#' generate .csv file used by bcbio
#'
#' @param sample_path path of .fastq files
#' @return a csv file contain basic sample meta info required for bcbio
get_sample_csv <- function(sample_path){
x=grep('\\.fastq',list.files(sample_path),value = T)
y=gsub('\\.fastq','',x)
z=cbind('samplename'=y,'description'=y)
write.csv(z,paste(sample_path,'samples.csv',sep = ''),row.names = F,quote = F)
}
#' wrapper for getting fold change, pvalue and FDR, by per cell line per time point
#'
#' @param cnt p by n matrix for p genes across n samples
#' @param grp_table dataframe with 3 columns: group, condition and control
#'  group: contains information which treatment samples will be compared against control cases in each group
#'  condition: indicates type of treatment, replicates have same condition
#'  control: TRUE for controls and FALSE for treatments
#'  order of well in samples annotation must be the same as the columns in count table
#' @param combine_fdr T for combine FDR and p-values with group and F for compute pairwisely
#' @param w n by p matrix for n samples and p factors for batch effect correction from RUVSeq
#' @param CommonDisp and TagwiseDisp used internally for passing overal dispersion to comparisons without replicates
#' @return list of 3 if combine_fdr = F: pmat,fdr_mat and logFC: all are p by m matrix for p genes across m types of treatments
#'         p by m+4 matrix for p genes across m types of treatments and p-value, LR,logCPM and FDR
edgeR_wrapper <- function(cnt,grp_table,combine_fdr = F,w = NULL,CommonDisp = NULL,TagwiseDisp = NULL){
library(edgeR)
design <- model.matrix(~condition,data = grp_table)
# add RUV batch effect correction when w exists
if(!is.null(w))  design <- cbind(design,w)
y <- DGEList(counts=cnt, group=grp_table$condition)
# Calculate overall dispersions when called first time
if(is.null(CommonDisp)){
y <- estimateGLMCommonDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
CommonDisp <- y$common.dispersion
TagwiseDisp <- y$tagwise.dispersion
}
if(length(grp_table$condition)==unique(length(grp_table$condition))){
# When both control and treatment lacking replicates, use overall dispersion instead
y$common.dispersion <- CommonDisp
y$tagwise.dispersion <- TagwiseDisp
}else{
y <- estimateGLMCommonDisp(y, design)
y <- estimateGLMTagwiseDisp(y, design)
}
# only anova-like FDR/Pvalues is required
if(combine_fdr){
y <- calcNormFactors(y)
fit <- glmFit(y, design)
lrt <- glmLRT(fit, coef=2:(ncol(design)))
lrt_tab <- topTags(lrt,n = Inf)$table[rownames(cnt),]
colnames(lrt_tab) <- gsub('logFC.condition','',colnames(lrt_tab))
return(lrt_tab)
}
# pairwise FDR/Pvalues is required
p_mat <- fdr_mat <- logFC <- NULL
col_names <- c()
for(i in unique(grp_table$group)){
grp_table_i <- grp_table[grp_table$group==i,]
ctr_row <- rownames(grp_table_i)[grp_table_i$control==T]
for (j in unique(grp_table_i$condition[grp_table_i$control!=T])){
j_row <- rownames(grp_table_i)[grp_table_i$condition==j]
grp_new <- rbind(grp_table[c(ctr_row,j_row),])
cnt_new <- cnt[,rownames(grp_new)]
result_new <- edgeR_wrapper(cnt_new,grp_new,combine_fdr = T,CommonDisp = CommonDisp,TagwiseDisp = TagwiseDisp)
if(is.null(p_mat)){
p_mat <- result_new$PValue
fdr_mat <- result_new$FDR
logFC <- result_new$logFC
if(length(unique(grp_table$condition))==2){
return_mat <- cbind('pval'=p_mat,'fdr'=fdr_mat,'logFC'=logFC)
rownames(return_mat) <- rownames(cnt_new)
return(return_mat)
}
}else{
p_mat <- cbind(p_mat,result_new$PValue)
fdr_mat <- cbind(fdr_mat,result_new$FDR)
logFC <- cbind(logFC,result_new$logFC)
}
col_names <- c(col_names,j)
}
}
colnames(p_mat) <- colnames(fdr_mat) <- colnames(logFC) <- col_names
rownames(p_mat) <- rownames(fdr_mat) <- rownames(logFC) <- rownames(cnt)
return(list('pmat'=p_mat,'fdr_mat'=fdr_mat,'logFC'=logFC))
}
# examine if there is task running on slurm
slurm_running <- function(job_name){
sacct_out <- system('sacct |grep ING',intern = T)
return(length(grep(job_name,sacct_out))>0)
}
quantile_normalisation <- function(df){
df_rank <- apply(df,2,rank,ties.method="min")
df_sorted <- data.frame(apply(df, 2, sort))
df_mean <- apply(df_sorted, 1, mean)
index_to_mean <- function(my_index, my_mean){
return(my_mean[my_index])
}
df_final <- apply(df_rank, 2, index_to_mean, my_mean=df_mean)
rownames(df_final) <- rownames(df)
return(df_final)
}
de_res <- edgeR_wrapper(cnt_sbl,meta)
View(de_res)
write.csv(cnt_sbl,'~/Dropbox/MU/workspace/liu_rnaseq/counts_symbol.csv')
write.csv(de_res,'~/Dropbox/MU/workspace/liu_rnaseq/de_symbol.csv')
cnetplot(x, categorySize="pvalue", foldChange=2^(genes_ens1$logFC),showCategory=2)
eg = bitr(rownames(genes_ens), fromType="ENSEMBL", toType="ENTREZID", OrgDb="org.Mm.eg.db")
genes_ens1 <- genes_ens[eg$ENSEMBL,]
genes_ens1 <- cbind(genes_ens1,'ENTREZID'=eg$ENTREZID)
x <- enrichPathway(gene=genes_ens1$ENTREZID,organism = 'mouse',pvalueCutoff=0.05, readable=T)
cnetplot(x, categorySize="pvalue", foldChange=2^(genes_ens1$logFC),showCategory=2)
de_res=de_res_symbol
de_res_symbol=de_res
?cnetplot
aaa=x@result
View(aaa)
y <- x
i=1
y <- x
y@result <- x@result[i,]
cnetplot(y, categorySize="pvalue", foldChange=2^(genes_ens1$logFC),showCategory=2)
y@result <- x@result[10,]
cnetplot(y, categorySize="pvalue", foldChange=2^(genes_ens1$logFC),showCategory=2)
cnetplot(y, categorySize="geneNum", foldChange=2^(genes_ens1$logFC),showCategory=1)
cnetplot(y, categorySize="geneNum", foldChange=2^(genes_ens1$logFC),showCategory=1)
y@gene2Symbol
?cnetplot
View(aaa)
View(de_res_symbol)
i=1
y <- x@result$geneID[i,]
y <- unlist(strsplit(x@result$geneID[i,],'/'))
y
i=1
y <- unlist(strsplit(x@result$geneID[i,],'/'))
y <- unlist(strsplit(x@result$geneID[i],'/'))
y
de_slt <- de_res_symbol[rownames(de_res_symbol)%in%y,]
View(de_slt)
View(de_slt)
source("http://bioconductor.org/biocLite.R")
biocLite("FGNet")
library(FGNet)
?fea_david
de_slt
gene_list <- rownames(de_slt)
aaa=as.list(org.Mm.eg.db)
head(aaa)
geneLabels <- unlist(as.list(org.Mm.eg.db)[geneList])
geneList <- rownames(de_slt)
geneLabels <- unlist(as.list(org.Mm.eg.db)[geneList])
geneLabels
gtf_file = '~/Dropbox/MU/workspace/DuelNorm/data/test.gtf'
gtf_info <- read_gtf(gtf_file)
source('~/Dropbox/MU/workspace/DuelNorm/src/lib.R')
gtf_info <- read_gtf(gtf_file)
gtf_info2 <- gtf_info[gtf_info$V3=='gene',c(1,4,5,7)]
View(gtf_info2)
